Chapter 1  
Introduction to Programming Lanuguages
====================================== 

### 1.1 Programming Languages

#### 1. Paradigms of computation (계산 패러다임)


- Imperative: machine instruction
  -  C/C++ (기계를 Control, 저장 되어 있는 값을 꺼내오고 , 연산후 결과를 저장 (명령))

# 
- Reduction: expressions 들을 평가
  - Expression의 복잡도를 줄임 ex) 1+2*3=> 7 
  -  Functional Style이라고도 한다
  -  모든것을 다 Expression으로 (ex 함수의 정의 , 계산하려고 하는 Expression)
  -  메모리 개념이 없는 경우가 많다. 오류를 줄일수 있고  개발속도가 빠를수있다.
  -  but 속도가 느리다.
# 

- Deduction: 논리적 추론


#### 2. Medium for representing of describing programs

##### For Imperative Style 
- Control(algorithm)+Data : Imperative 스타일
  - double PI=3.14 여기서 PI 는 값의 주소를 나타내는것
# 

##### For Reduction Style
- Functions + Expressions :Reduction 스타일
  - 메모리 개념이 없다고 위에 설명했고 , 만약 변수가 있더라 하더도 메모리의 binding 된게 아니라 그냥 값의 이름이다.
  - PI = 3.14 는 어디에 있건 상관이없다 (즉 메모리의 개념이 없다)
  - 그렇다면 이름을 어디서 가져올것인가? 이름을 Mapping 하는 테이블이 있을수 있다
  - 그렇지 않다면 Assembly로 번역됐을때 Imperative 스타일 처럼 메모리개념이 생김
  - Reduction Style 프로그램 소스에서의 변수는 어디에 있건 신경을 안써도 된다.
# 

##### For Deduction Style
- Logic + Control : Logic은 연역법에 쓰일 규칙들을 정의하고, Control은 저 Logic들을 어느순서로 적용할 것인지
# 

#### 3. Definition of programming languages

- Syntax : 구문
- Semantics : 의미
- Pragmatics : 실용 (공학적 측면)
   1. Complexity of implementation : 구현의 복잡성  
   # 
   
   2. Expressive power 
   
      - c에서 t=t+1을 assembly 언어에서는 load, store 명령어 등 훨씬 복잡해진다.
      - Expression power가 높아지면 Algoritm이 간단히 표시된다=> 오류가 날 가능성이 낮아진다.
      - 근데 Expression Power를 높이면 번역의 번역을 거쳐서 성능이 문제가 될 수 있다.                
   # 

   3. Suitability to given problems : Application-oriented view point  
      - Application 만들때 그에 맞는 언어를 선택하는 것임 ex) Web Browser 만들때 왜 C언어를 사용하지 않냐? 사용자 공간을 무조건 접근 가능하고 , assembly로 Browser 구현하는것은 매우 힘든일이 될 것이다.


#### 4. Execution Model
- Sequential execution (폰 노이만 기계)
- Concurrent of parallel execution (인공지능 , gpu)

#### 5. Abstraction
- 불필요한 내용 빼고 본질만, 덩어리를 나눌때 연관성이 없어야 좋다.


---
### 1.2 Goals (프로그래밍 언어론을 배우는 이유)
- 프로그래밍 언어의 design spaces(프로그램 설계 할때 선택할 수 있는 모음 ex(Exception)) 을 이해하기 위해서
- 사용하는 언어를 더 잘 이해하기 위해
- 다양한 언어 특성과 연관된 프로그래밍 기술 이해하기 위해서
  - 언어 특성을 가지고 문제 해결시 무슨언어 선택, Web Server에서 확장할때 Python ,Js중 선택한다든지
  - Machine Learning 에서 Python, Prolog, Lisp 중에 선택 한다든지

- => 결국에는 오류가없이 정확, 성능, 보안으로 귀결됨
  
---
### 1.3 History
1. 1950's : 포트란과 코볼 , 포트란때 Compiler가 만들어짐
2. 1960's : Lisp: Higher-order function, Garbage Collection. Algo-family: Type 시스템, 데이타 구조
3. 1970's : Abstract data type ex)c++의 클래스와 같은 , 그리고 Objects의 등장
4. 1980's : Objects의 시대
5. 1990's : Network-centric computing, Interoperability, security and correct-ness.

![Image of Programming Language History](/Images/1장그림_1.PNG)



---
### 1.4 Programming Languages and Problem Solving
1. 문제분석
2. 문제에 적절한 언어정의
3. 언어 구현
4. 솔루션 Build
5. Review and Evaluate
#### bug 잡는게 제일 중요

---
###### 용어설명
- Expression : 값의 기술
- Higher-order function : 함수 자체를 값으로, 값으로 취급하니 인자전달도 가능하고 Return 값으로도 받을 수 있다.
- Garbage Collection : 메모리 공간을 확보하기 위해 참조되지 않는 Reference들을 Free Space로 돌려보내는것
- Interoperability : 상호연결 (디바이스, 시스템, 어플리케이션간의)